#!/usr/bin/python3
#
# Part of RedELK
#
# Author: Lorenzo Bernardi / @fastlorenzo
#
from modules.helpers import *
import traceback
import config

info = {
    'version': 0.1,
    'name': 'dummy_alarm module',
    'alarmmsg': 'ALARM GENERATED BY LASTLINE',
    'description': 'This alarm always triggers. It lists the last 2 haproxy lines as hit',
    'type': 'redelk_alarm-NOTINUSE',
    'submodule': 'alarm_dummy'
}

class Module():
    def __init__(self):
        #print("class init")
        pass

    def run(self):
        ret = {}
        alarmLines = []
        results = {}
        try:
            report = self.alarm_check1()
            alarmLines = report.get('alarmLines', [])
            results = report.get('results', {})
            # TODO before returning we might have to set an tag on our resultset so we alarm only once. (maybe a tag per alarm?  "ALARMED_%s"%report['fname'] migt do)
            setTags("ALARMED_%s" % info['submodule'], alarmLines)
        except Exception as e:
            stackTrace = traceback.format_exc()
            ret['error'] = stackTrace
            pass
        ret['info'] = info
        ret['hits'] = {}
        ret['hits']['hits'] = alarmLines
        ret['hits']['total'] = len(alarmLines)
        ret['results'] = results
        print("[a] finished running module %s . result: %s hits"%(ret['info']['name'],ret['hits']['total']))
        #print(ret)
        return(ret)

    def alarm_check1(self):
        # This check queries for IP's that aren't listed in any iplist* but do talk to c2* paths on redirectors\n
        q = "NOT tags:iplist_* AND redir.backend.name:c2* AND NOT tags:ALARMED_* AND tags:enrich_*"
        i = countQuery(q)
        if i >= 10000:
            i = 10000
        r = getQuery(q, i)
        report = {}
        report['alarm'] = False
        # if i > 0: report['alarm'] = True #if the query gives 'new ip's we hit on them
        report['fname'] = "alarm_check1"
        report['name'] = "Unkown IP to C2"
        report['description'] = "This check queries for IP's that aren't listed in any iplist* but do talk to c2* paths on redirectors\n"
        report['query'] = q
        UniqueIPs = {}
        if type(r) != type([]):
            r = []
        rAlarmed = []
        for ip in r:
            # give enrichment 5 minutes to catch up.
            nowDelayed = datetime.utcnow() - timedelta(minutes=5)
            d = ip['_source']['@timestamp']
            timestamp = datetime.strptime(d, '%Y-%m-%dT%H:%M:%S.%fZ')
            # if timestamp > nowDelayed:
            #  print("item to new %s < %s"%(timestamp,nowDelayed))
            if timestamp < nowDelayed:
                #print("[D] %s < %s"%(timestamp,nowDelayed))
                #print("[D]%s"% ip['_id'])
                rAlarmed.append(ip)
                sip = getValue('_source.source.ip', ip)
                if sip not in UniqueIPs:
                    UniqueIPs[sip] = {}
            UniqueIPs[sip]['http.request.body.content'] = getValue('_source.http.request.body.content', ip)
            UniqueIPs[sip]['source.ip'] = sip
            UniqueIPs[sip]['source.nat.ip'] = getValue('_source.source.nat.ip', ip)
            UniqueIPs[sip]['country_name'] = getValue('_source.source.geo.country_name', ip)
            UniqueIPs[sip]['ISP'] = getValue('_source.source.as.organization.name', ip)
            UniqueIPs[sip]['redir.frontend.name'] = getValue('_source.redir.frontend.name', ip)
            UniqueIPs[sip]['redir.backend.name'] = getValue('_source.redir.backend.name', ip)
            UniqueIPs[sip]['infra.attack_scenario'] = getValue('_source.infra.attack_scenario', ip)
            UniqueIPs[sip]['tags'] = getValue('_source.tags', ip)
            UniqueIPs[sip]['redir.timestamp'] = getValue('_source.redir.timestamp', ip)
            report['alarm'] = True
            print("[A] alarm set in %s" % report['fname'])
            if 'times_seen' in UniqueIPs[sip]:
                UniqueIPs[sip]['times_seen'] += 1
            else:
                UniqueIPs[sip]['times_seen'] = 1
        report['results'] = UniqueIPs
        with open("/tmp/ALARMED_alarm_check1.ips", "a") as f:
            for ip in UniqueIPs:
                f.write("%s\n" % ip)
        report['alarmLines'] = rAlarmed
        return(report)
